# Install Think Tool
echo "Installing enhanced Think Tool..."
cat > "$CURSOR_TOOLS_DIR/think-tool.js" << 'EOF'
/**
 * Enhanced Think Tool - A sophisticated reasoning utility for Cursor IDE
 * 
 * This tool provides strategic reasoning about coding tasks by:
 * 1. Analyzing the current project structure and context
 * 2. Identifying applicable MCP guidelines and constraints
 * 3. Suggesting specific approaches and tool combinations
 * 4. Generating a detailed plan with implementation steps
 * 
 * Particularly effective for:
 * - Complex component development
 * - MCP compliance verification
 * - Integration planning
 * - Architecture decisions
 */

const logger = require('./logger');
const fs = require('fs');
const path = require('path');

/**
 * Input class for the think tool with expanded context support
 */
class ThinkToolInput {
    /**
     * Create a new ThinkToolInput
     * 
     * @param {string} question - The task or question to analyze
     * @param {Object} context - Optional context information
     * @param {string} context.mcpContext - Current MCP context ID
     * @param {string} context.projectPath - Current project path
     * @param {string} context.selectedText - Currently selected text in editor
     * @param {string} context.currentFile - Path to current file being edited
     */
    constructor(question, context = {}) {
        this.question = question;
        this.context = {
            mcpContext: context.mcpContext || 'content-ops',
            projectPath: context.projectPath || process.cwd(),
            selectedText: context.selectedText || '',
            currentFile: context.currentFile || '',
            activeTools: context.activeTools || []
        };
    }
}

/**
 * Analyzes project structure to provide context-aware reasoning
 * 
 * @param {string} projectPath - Path to the project root
 * @returns {Object} - Project structure information
 */
function analyzeProjectStructure(projectPath) {
    try {
        // Check if the path exists
        if (!fs.existsSync(projectPath)) {
            return { 
                error: 'Project path does not exist',
                structureType: 'unknown'
            };
        }

        // Look for key files to determine project type
        const hasPackageJson = fs.existsSync(path.join(projectPath, 'package.json'));
        const hasNextConfig = fs.existsSync(path.join(projectPath, 'next.config.js'));
        const hasSrcDir = fs.existsSync(path.join(projectPath, 'src'));
        const hasComponentsDir = fs.existsSync(path.join(projectPath, 'components')) || 
                                 (hasSrcDir && fs.existsSync(path.join(projectPath, 'src', 'components')));
        const hasPagesDir = fs.existsSync(path.join(projectPath, 'pages')) || 
                           (hasSrcDir && fs.existsSync(path.join(projectPath, 'src', 'pages')));

        // Determine project type
        let projectType = 'unknown';
        if (hasNextConfig) {
            projectType = 'next.js';
        } else if (hasPackageJson) {
            try {
                const packageJson = JSON.parse(fs.readFileSync(path.join(projectPath, 'package.json'), 'utf8'));
                if (packageJson.dependencies) {
                    if (packageJson.dependencies.react) {
                        projectType = 'react';
                    } else if (packageJson.dependencies.vue) {
                        projectType = 'vue';
                    } else if (packageJson.dependencies.angular) {
                        projectType = 'angular';
                    }
                }
            } catch (err) {
                logger.error(`Error parsing package.json: ${err.message}`);
            }
        }

        return {
            projectType,
            structure: {
                hasSrcDir,
                hasComponentsDir,
                hasPagesDir,
                hasPackageJson,
                hasNextConfig
            }
        };
    } catch (err) {
        logger.error(`Error analyzing project structure: ${err.message}`);
        return { error: err.message, structureType: 'unknown' };
    }
}

/**
 * Enhanced reasoning system that considers project context and MCP guidelines
 * 
 * @param {ThinkToolInput} input - The input containing task and context
 * @returns {Object} - Detailed reasoning object
 */
function enhancedReasoningSystem(input) {
    const question = input.question.toLowerCase();
    const mcpContext = input.context.mcpContext;
    
    // Analyze project structure
    const projectStructure = analyzeProjectStructure(input.context.projectPath);
    
    // Detect task intent
    let taskType = 'unknown';
    if (question.includes('component') || question.includes('tsx') || question.includes('jsx')) {
        taskType = 'component-development';
    } else if (question.includes('integrate') || question.includes('api') || question.includes('service')) {
        taskType = 'integration';
    } else if (question.includes('content') || question.includes('page') || question.includes('article')) {
        taskType = 'content-operations';
    } else if (question.includes('performance') || question.includes('optimize') || question.includes('speed')) {
        taskType = 'performance-optimization';
    } else if (question.includes('test') || question.includes('validate') || question.includes('verify')) {
        taskType = 'testing-validation';
    }
    
    // Identify applicable MCP guidelines
    let mcpGuidelines = [];
    if (mcpContext === 'content-ops') {
        mcpGuidelines = [
            'Follow content model structure',
            'Ensure proper HTML-TSX pairing',
            'Include metadata for SEO',
            'Validate against content specifications'
        ];
    } else if (mcpContext === 'tsx-development') {
        mcpGuidelines = [
            'Use TypeScript interfaces for all props',
            'Implement component-scoped CSS modules',
            'Follow accessibility guidelines',
            'Maintain separation of concerns'
        ];
    } else if (mcpContext === 'integration') {
        mcpGuidelines = [
            'Isolate third-party code in dedicated modules',
            'Use CSS scoping to prevent style leakage',
            'Implement clear adapter patterns',
            'Handle error states and loading states'
        ];
    }
    
    // Recommend tools based on task type and MCP context
    let recommendedTools = [];
    if (taskType === 'component-development') {
        recommendedTools = ['component-creator', 'mcp-validator', 'accessibility-checker'];
    } else if (taskType === 'integration') {
        recommendedTools = ['api-analyzer', 'compatibility-checker', 'mcp-validator'];
    } else if (taskType === 'content-operations') {
        recommendedTools = ['html-tsx-pairing', 'mcp-validator', 'markdown-fixer'];
    } else if (taskType === 'performance-optimization') {
        recommendedTools = ['performance-optimizer', 'bundle-analyzer', 'image-optimizer'];
    } else if (taskType === 'testing-validation') {
        recommendedTools = ['mcp-validator', 'test-generator', 'a11y-checker'];
    }
    
    // Generate step-by-step approach
    let steps = [];
    if (taskType === 'component-development') {
        steps = [
            'Create component scaffolding using the component-creator tool',
            'Implement the component interface following TypeScript best practices',
            'Add CSS modules with proper scoping and variables',
            'Validate against MCP guidelines',
            'Implement accessibility features',
            'Test the component'
        ];
    } else if (taskType === 'integration') {
        steps = [
            'Analyze the third-party API or service',
            'Create adapter layer for the integration',
            'Implement proper CSS isolation',
            'Convert JS components to TypeScript',
            'Update asset references to use correct paths',
            'Validate against MCP guidelines',
            'Test the integration'
        ];
    } else if (taskType === 'content-operations') {
        steps = [
            'Create HTML template with proper data attributes',
            'Implement corresponding TSX component',
            'Ensure metadata is properly defined',
            'Validate HTML-TSX pairing',
            'Optimize for SEO',
            'Test content rendering'
        ];
    }
    
    // Generate detailed reasoning
    return {
        taskType,
        projectStructure,
        mcpContext,
        mcpGuidelines,
        recommendedTools,
        steps,
        summary: `To approach this ${taskType} task in a ${mcpContext} context, I recommend following the MCP guidelines for ${mcpContext} and using the ${recommendedTools.join(', ')} tools. The implementation should proceed through ${steps.length} steps, focusing on proper structure and validation.`
    };
}

/**
 * Enhanced think tool function with MCP awareness
 * 
 * @param {ThinkToolInput|Object} input - The input containing the task/question and context
 * @returns {Promise<string>} - A promise that resolves to a detailed approach
 */
async function thinkTool(input) {
    // Normalize input to ThinkToolInput instance
    if (!(input instanceof ThinkToolInput)) {
        input = new ThinkToolInput(
            typeof input === 'string' ? input : input.question || 'Unknown task',
            typeof input === 'object' ? input.context || {} : {}
        );
    }
    
    logger.info(`THINKING about task: ${input.question} in ${input.context.mcpContext} context`);
    
    try {
        // Use enhanced reasoning system
        const reasoning = enhancedReasoningSystem(input);
        
        // Format the output
        const formattedReasoningOutput = `
# Task Analysis: ${reasoning.taskType}

## Project Context
- Project Type: ${reasoning.projectStructure.projectType || 'Unknown'}
- MCP Context: ${reasoning.mcpContext}

## Applicable MCP Guidelines
${reasoning.mcpGuidelines.map(g => `- ${g}`).join('\n')}

## Recommended Tools
${reasoning.recommendedTools.map(t => `- ${t}`).join('\n')}

## Implementation Steps
${reasoning.steps.map((s, i) => `${i+1}. ${s}`).join('\n')}

## Summary
${reasoning.summary}
        `;
        
        return formattedReasoningOutput.trim();
    } catch (error) {
        logger.error(`Error in enhanced thinkTool: ${error.message}`);
        return `Error occurred while thinking about the task: ${error.message}. Please try again with more specific information.`;
    }
}

module.exports = {
    ThinkToolInput,
    thinkTool,
    analyzeProjectStructure
};
EOF

# Install Component Creator Tool
echo "Installing Component Creator Tool..."
cat > "$CURSOR_TOOLS_DIR/component-creator.js" << 'EOF'
#!/usr/bin/env node

/**
 * Component Creator Tool
 * 
 * Creates new components following the HTML-TSX Protocol with proper
 * TypeScript interfaces, CSS modules, and directory structure.
 * 
 * Usage:
 *   cursor-tool component-create MyComponent --type page --app myapp
 */

const fs = require('fs');
const path = require('path');
const logger = require('./logger');
const toolRegistry = require('./tool-registry');

/**
 * ComponentCreatorInput defines the input parameters for the component creator
 */
class ComponentCreatorInput {
    /**
     * Create a new ComponentCreatorInput
     * 
     * @param {string} name - Component name
     * @param {Object} options - Component options
     * @param {string} options.type - Component type (page, block, ui)
     * @param {string} options.app - Optional app name for integration
     * @param {string} options.description - Component description
     * @param {boolean} options.withTest - Generate test file
     * @param {boolean} options.withStory - Generate Storybook story
     * @param {string} options.projectRoot - Project root directory
     */
    constructor(name, options = {}) {
        this.name = name;
        this.options = {
            type: options.type || 'ui',
            app: options.app || '',
            description: options.description || '',
            withTest: options.withTest || false,
            withStory: options.withStory || false,
            projectRoot: options.projectRoot || process.cwd()
        };
    }
}

/**
 * Get directory paths based on project structure
 * 
 * @param {string} projectRoot - Project root directory
 * @returns {Object} - Directory paths
 */
function getDirectoryPaths(projectRoot) {
    // Check if src directory exists
    const hasSrcDir = fs.existsSync(path.join(projectRoot, 'src'));
    
    // Default paths
    const paths = {
        components: hasSrcDir ? path.join(projectRoot, 'src', 'components') : path.join(projectRoot, 'components'),
        pages: hasSrcDir ? path.join(projectRoot, 'src', 'pages') : path.join(projectRoot, 'pages'),
        styles: hasSrcDir ? path.join(projectRoot, 'src', 'styles') : path.join(projectRoot, 'styles'),
        public: path.join(projectRoot, 'public'),
        test: path.join(projectRoot, '__tests__')
    };
    
    // Create directories if they don't exist
    Object.values(paths).forEach(dir => {
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
            logger.info(`Created directory: ${dir}`);
        }
    });
    
    return paths;
}

/**
 * Generate component code
 * 
 * @param {string} name - Component name
 * @param {string} type - Component type
 * @param {string} app - App name (optional)
 * @returns {string} - Component code
 */
function generateComponentCode(name, type, app = '') {
    const className = app 
        ? `@/styles/${app.toLowerCase()}-${name.toLowerCase()}.module.css` 
        : `@/styles/${name.toLowerCase()}.module.css`;
    
    return `import React from 'react';
import styles from '${className}';

${type === 'page' 
    ? `// Page component props
interface ${name}Props {
  title?: string;
  description?: string;
  className?: string;
}` 
    : `// Component props
interface ${name}Props {
  className?: string;
  children?: React.ReactNode;
}`}

/**
 * ${name} ${type} component
 ${app ? `* Part of the ${app} application` : ''}
 * 
 * @param props - Component properties
 * @returns React component
 */
const ${name}: React.FC<${name}Props> = ({ 
  ${type === 'page' 
    ? 'title = "Default Title", description = "Default description", className = ""' 
    : 'className = "", children'} 
}) => {
  return (
    <div className={${app ? `\`\${styles.root} \${styles.container} \${className}\`` : '`${styles.root} ${className}`'}}>
      ${type === 'page' 
        ? `<div className={styles.header}>
        <h1 className={styles.title}>{title}</h1>
        <p className={styles.description}>{description}</p>
      </div>
      <div className={styles.content}>
        {/* Page content goes here */}
      </div>`
        : `{/* Component content */}
      {children}`}
    </div>
  );
};

export default ${name};
`;
}

/**
 * Generate CSS module code
 * 
 * @param {string} name - Component name
 * @param {string} app - App name (optional)
 * @returns {string} - CSS module code
 */
function generateCssModule(name, app = '') {
    const prefix = app ? `--${app.toLowerCase()}-` : '--app-';
    const isPage = name.toLowerCase().endsWith('page');
    
    return `/* ${name} styles */
.root {
  /* CSS variables scoped to this component */
  ${prefix}primary-color: #0a2856;
  ${prefix}secondary-color: #c19b4a;
  ${prefix}text-color: #333333;
  ${prefix}background-color: #ffffff;
}

.container {
  display: flex;
  flex-direction: column;
  padding: 1rem;
}

${isPage 
  ? `.header {
  margin-bottom: 2rem;
}

.title {
  font-size: 2rem;
  font-weight: bold;
  color: var(${prefix}primary-color);
  margin-bottom: 0.5rem;
}

.description {
  font-size: 1rem;
  color: var(${prefix}text-color);
}

.content {
  flex: 1;
}`
  : '/* Additional component-specific styles */'}
`;
}

/**
 * Generate HTML page code
 * 
 * @param {string} name - Component name
 * @returns {string} - HTML page code
 */
function generateHtmlPage(name) {
    const title = name.replace(/([A-Z])/g, ' $1').trim();
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
</head>
<body>
  <main data-component-id="${name.toLowerCase()}" 
        data-props='{"title":"${title}","description":"${title} page description"}'>
    <h1>${title}</h1>
    <p>${title} page description</p>
    <div class="content">
      <!-- Page content goes here -->
    </div>
  </main>
</body>
</html>
`;
}

/**
 * Component creator function
 * 
 * @param {ComponentCreatorInput} input - Component creator input
 * @returns {Promise<Object>} - Result object with status and file paths
 */
async function componentCreator(input) {
    try {
        // Normalize component name to PascalCase
        let componentName = input.name;
        if (!componentName.match(/^[A-Z][a-zA-Z0-9]*$/)) {
            componentName = componentName
                .replace(/[\W_]+/g, ' ')
                .split(' ')
                .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
                .join('');
        }
        
        // Get directory paths
        const dirs = getDirectoryPaths(input.options.projectRoot);
        
        // Create component directory
        const componentDir = path.join(dirs.components, input.options.type === 'page' ? 'pages' : '');
        if (!fs.existsSync(componentDir)) {
            fs.mkdirSync(componentDir, { recursive: true });
        }
        
        // Create component file
        const componentPath = path.join(componentDir, `${componentName}.tsx`);
        const componentCode = generateComponentCode(componentName, input.options.type, input.options.app);
        fs.writeFileSync(componentPath, componentCode);
        
        // Create CSS module
        const cssModulePath = path.join(dirs.styles, `${componentName.toLowerCase()}.module.css`);
        const cssCode = generateCssModule(componentName, input.options.app);
        fs.writeFileSync(cssModulePath, cssCode);
        
        // Create HTML file for pages
        let htmlPath = null;
        if (input.options.type === 'page') {
            htmlPath = path.join(dirs.public, `${componentName.toLowerCase()}.html`);
            const htmlCode = generateHtmlPage(componentName);
            fs.writeFileSync(htmlPath, htmlCode);
        }
        
        return {
            success: true,
            componentName,
            files: {
                component: componentPath,
                cssModule: cssModulePath,
                html: htmlPath
            }
        };
    } catch (error) {
        logger.error(`Error creating component: ${error.message}`);
        return {
            success: false,
            error: error.message
        };
    }
}

// Register with the tool registry
toolRegistry.registerTool('component-creator', componentCreator, {
    description: 'Creates new components following the HTML-TSX Protocol',
    parameters: ['name', 'options'],
    category: 'development',
    author: 'Cursor',
    version: '1.0.0'
});

module.exports = {
    ComponentCreatorInput,
    componentCreator
};
EOF#!/usr/bin/env bash

# Cursor Configuration Installer
# 
# This script sets up the enhanced cursor configuration with:
# - Updated MCP (Model Context Protocol)
# - Enhanced tool registry
# - Component creator tool
# - MCP validator tool
# - Think tool
#
# Usage: ./install-cursor-config.sh [--force]

set -e

# Configuration
CURSOR_CONFIG_DIR="$HOME/.cursor/config"
CURSOR_TOOLS_DIR="$HOME/.cursor/config/tools"
FORCE_INSTALL=false

# Parse arguments
for arg in "$@"; do
  case $arg in
    --force)
      FORCE_INSTALL=true
      shift
      ;;
    *)
      # Unknown option
      ;;
  esac
done

# Check if directories exist
if [ ! -d "$CURSOR_CONFIG_DIR" ]; then
  echo "Creating cursor config directory: $CURSOR_CONFIG_DIR"
  mkdir -p "$CURSOR_CONFIG_DIR"
fi

if [ ! -d "$CURSOR_TOOLS_DIR" ]; then
  echo "Creating cursor tools directory: $CURSOR_TOOLS_DIR"
  mkdir -p "$CURSOR_TOOLS_DIR"
fi

# Backup existing files
backup_directory="$CURSOR_CONFIG_DIR/backup-$(date +%Y%m%d-%H%M%S)"
mkdir -p "$backup_directory"

echo "Creating backup of existing configuration in $backup_directory"
cp -r "$CURSOR_CONFIG_DIR"/* "$backup_directory" 2>/dev/null || true

# Install enhanced mcp.json
echo "Installing enhanced MCP JSON configuration..."
cat > "$CURSOR_CONFIG_DIR/mcp.json" << 'EOF'
{
  "version": "2.0",
  "contexts": [
    {
      "id": "content-ops",
      "name": "Content Operations",
      "description": "Context for content management and operations in Next.js applications",
      "settings": {
        "model": "claude-3-opus-20240229",
        "temperature": 0.4,
        "max_tokens": 4000
      },
      "rules": {
        "tone": "technical",
        "style": "concise",
        "formatting": "code_blocks",
        "boundaries": "Focus on React, TypeScript, and component development",
        "fallback": "Reference React documentation"
      },
      "privacy": {
        "data_retention": "session",
        "logging": "minimal"
      },
      "tools": [
        "component-creator",
        "performance-optimizer",
        "accessibility-checker"
      ],
      "protocolFiles": [
        "~/.cursor/config/HTML_TSX_PROTOCOL copy.md"
      ]
    },
    {
      "id": "integration",
      "name": "Third-party Integration",
      "description": "Context for integrating external applications into Next.js",
      "settings": {
        "model": "claude-3-opus-20240229",
        "temperature": 0.5,
        "max_tokens": 4000
      },
      "rules": {
        "tone": "analytical",
        "style": "detailed",
        "formatting": "markdown",
        "boundaries": "Focus on API integration, third-party services, and conversion workflows",
        "fallback": "Suggest integration patterns or documentation"
      },
      "privacy": {
        "data_retention": "session",
        "logging": "minimal"
      },
      "tools": [
        "api-analyzer",
        "mcp-validator",
        "compatibility-checker"
      ],
      "protocolFiles": [
        "~/.cursor/config/Model Context Protocol (MCP) for Replit Integration copy.md"
      ]
    },
    {
      "id": "ai-tools",
      "name": "AI Tools Development",
      "description": "Context for developing AI-powered tools and integrations",
      "settings": {
        "model": "claude-3-sonnet-20240229",
        "temperature": 0.7,
        "max_tokens": 4000
      },
      "rules": {
        "tone": "collaborative",
        "style": "instructive",
        "formatting": "mixed",
        "boundaries": "Focus on AI tools, workflows, and integration with development processes",
        "fallback": "Suggest relevant AI development patterns"
      },
      "privacy": {
        "data_retention": "session",
        "logging": "minimal"
      },
      "tools": [
        "think-tool",
        "mcp-validator",
        "tool-generator"
      ],
      "protocolFiles": [
        "~/.cursor/config/tools copy/think-tool.js"
      ]
    }
  ],
  "toolPaths": {
    "base": "~/.cursor/config/tools",
    "userTools": "~/.cursor/tools"
  },
  "features": {
    "autoContext": true,
    "contextAwareCompletion": true,
    "mcpValidation": {
      "enabled": true,
      "onSave": true,
      "onCommit": true
    },
    "componentGeneration": {
      "defaultType": "page",
      "useTypescript": true,
      "cssModules": true
    }
  },
  "editor": {
    "highlightMCP": true,
    "showContextInStatusBar": true,
    "validateOnType": false,
    "suggestMCPFixes": true
  }
}
EOF229",
        "temperature": 0.5,
        "max_tokens": 4000
      },
      "rules": {
        "tone": "professional",
        "style": "detailed",
        "formatting": "markdown",
        "boundaries": "Focus on content operations, Next.js, and component frameworks",
        "fallback": "Suggest relevant documentation or tools"
      },
      "privacy": {
        "data_retention": "session",
        "logging": "minimal"
      },
      "tools": [
        "component-creator",
        "mcp-validator",
        "html-tsx-pairing"
      ],
      "protocolFiles": [
        "~/.cursor/config/Model Context Protocol (MCP) for content-ops-starter.md"
      ]
    },
    {
      "id": "tsx-development",
      "name": "TSX Development",
      "description": "Context for developing TypeScript React components with best practices",
      "settings": {
        "model": "claude-3-opus-20240